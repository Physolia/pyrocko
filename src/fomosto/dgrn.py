# http://pyrocko.org - GPLv3
#
# The Pyrocko Developers, 21st Century
# ---|P------/S----------~Lg----------
from __future__ import absolute_import, division

import numpy as num
import logging
import os
import shutil
import math
import copy
import signal

from tempfile import mkdtemp
from subprocess import Popen, PIPE
from os.path import join as pjoin

from pyrocko import gf
from pyrocko import trace, util, cake
from pyrocko.moment_tensor import MomentTensor, symmat6
from pyrocko.guts import Float, Int, Tuple, List, Complex, Bool, Object, String

km = 1e3

guts_prefix = 'pf'

Timing = gf.meta.Timing

logger = logging.getLogger('pyrocko.fomosto.dgrn')

# how to call the programs
program_bins = {
    'dgrn.2020': 'fomosto_dgrn2020',
}


def have_backend():
    have_any = False
    for cmd in [[exe] for exe in program_bins.values()]:
        try:
            p = Popen(cmd, stdout=PIPE, stderr=PIPE, stdin=PIPE)
            (stdout, stderr) = p.communicate()
            have_any = True

        except OSError:
            pass

    return have_any


dgrn_displ_names = ('uz', 'ur', 'ut')


def nextpow2(i):
    return 2**int(math.ceil(math.log(i)/math.log(2.)))


def str_float_vals(vals):
    return ' '.join('%e' % val for val in vals)


def str_int_vals(vals):
    return ' '.join('%i' % val for val in vals)


def str_str_vals(vals):
    return ' '.join("'%s'" % val for val in vals)


def scl(cs):
    if not cs:
        return '\n#'

    return '\n'+' '.join('(%e,%e)' % (c.real, c.imag) for c in cs)


def cake_model_to_config(mod):
    k = 1000.
    srows = []
    for i, row in enumerate(mod.to_scanlines()):
        depth, vp, vs, rho, _, _ = row
        row = [depth/k, vp/k, vs/k, rho/k]
        srows.append('%i %s' % (i+1, str_float_vals(row)))

    return '\n'.join(srows), len(srows)


class DGrnSpatialSampling(Object):
    n_steps = Int.T(default=101)
    start = Float.T(
        default=0.,
        help='start sampling [km]')
    end = Float.T(
        default=100.,
        help='end sampling [km]')
    sampling_interval_ratio = Float.T(
        default=1.0,
        help='exponential sampling 1.- equidistant, > 1. decreasing sampling'
             ' with distance')

    def string_for_config(self):
        return '%i %15e %15e %e' % (self.n_steps, self.start, self.end,
                                    self.sampling_interval_ratio)


class DGrnConfig(Object):
    dgrn_version = String.T(default='2020')

    accuracy_wavenumber_integration = Float.T(default=0.01)

    def items(self):
        return dict(self.T.inamevals(self))


class DGrnConfigFull(DGrnConfig):

    receiver_depth = Float.T(default=0.0)

    distance_grid = DGrnSpatialSampling.T(DGrnSpatialSampling.D())
    depth_grid = DGrnSpatialSampling.T(DGrnSpatialSampling.D())

    dgrn_outdir = String.T(default='dgrn_green/')

    displ_filenames = Tuple.T(3, String.T(), default=dgrn_displ_names)

    earthmodel_1d = gf.meta.Earthmodel1D.T(optional=True)

    @staticmethod
    def example():
        conf = DGrnConfigFull()
        conf.earthmodel_1d = cake.load_model().extract(depth_max=560.*km)
        return conf

    def string_for_config(self):

        assert self.distance_grid.sampling_interval_ratio >= 1.
        assert self.depth_grid.sampling_interval_ratio >= 1.
        assert self.earthmodel_1d is not None

        d = self.__dict__.copy()

        model_str, nlines = cake_model_to_config(self.earthmodel_1d)
        d['n_model_lines'] = nlines
        d['model_lines'] = model_str

        d['str_distance_grid'] = self.distance_grid.string_for_config()
        d['str_depth_grid'] = self.depth_grid.string_for_config()

        d['str_dgrn_outdir'] = "'%s'" % './'

        d['str_displ_filenames'] = str_str_vals(self.displ_filenames)

        template = '''# autogenerated DGRN input by dgrn.py
#=============================================================================
# This is the input file of FORTRAN77 program "dgrn2020" for calculating
# differential Green's functions of a multi-layered elastic half-space in
# reference to a homogeneous elastic halfspace (i.e., layering and gravity
# effects). All results will be stored in the given directory and provide the
# necessary data base for the program "sdm", "ids", etc. for geodetic and
# seismo-geodetic source inversions.
#
# written by Rongjiang Wang
# GFZ German Research Centre for Geosciences
# e-mail: wang@gfz-potsdam.de
# phone +49 331 2881209
# fax +49 331 2881204
#
# Last modified: Potsdam, April, 2020
#
#################################################################
##                                                             ##
## Cylindrical coordinates (Z positive downwards!) are used.   ##
##                                                             ##
## If not specified otherwise, SI Unit System is used overall! ##
##                                                             ##
#################################################################
#
#------------------------------------------------------------------------------
#
#    PARAMETERS FOR SOURCE-OBSERVATION CONFIGURATIONS
#    ================================================
# 1. the uniform depth of the observation points [km];
# 2. number of (horizontal) source-observation distances (> 1), start and end
#    distances [km], ratio (>= 1.0) between max. and min. sampling interval
#    (1.0 for equidistant sampling);
# 3. number of source depths (>= 1), start and end source depths [km], ratio
#    (>= 1.0) between max. and min. sampling interval (1.0 for equidistant
#    sampling);
#
#    r1,r2 = minimum and maximum horizontal source-observation
#            distances (r2 > r1 >= 0).
#    zs1,zs2 = minimum and maximum source depths (zs2 > zs1 > 0).
#
#------------------------------------------------------------------------------
 %(receiver_depth)f
 %(str_distance_grid)s
 %(str_depth_grid)s
#------------------------------------------------------------------------------
#
#    PARAMETERS FOR WAVENUMBER INTEGRATION
#    =====================================
# 1. relative accuracy of the wave-number integration (suggested: 0.1 - 0.01)
#------------------------------------------------------------------------------
 %(accuracy_wavenumber_integration)e
#------------------------------------------------------------------------------
#
#    PARAMETERS FOR OUTPUT FILES
#    ===========================
#
# 1. output directory
# 2. file names for 3 displacement components (uz, ur, ut)
#
#    Note that all file or directory names should not be longer than 80
#    characters. Directory and subdirectoy names must be separated and ended
#    by /. All file names should be given without extensions that will be
#    appended automatically by ".ss" for the strike-slip source, ".ds" for the
#    dip-slip source, and ".cl" for the compensated linear vector dipole source)
#
#------------------------------------------------------------------------------
 %(str_dgrn_outdir)s
 %(str_displ_filenames)s
#------------------------------------------------------------------------------
#
#    GLOBAL MODEL PARAMETERS
#    =======================
# 1. number of data lines of the layered model (<= lmax as defined in psgglob.h)
#
#    The surface and the upper boundary of the half-space as well as the
#    interfaces at which the poroelastic parameters are continuous, are all
#    defined by a single data line; All other interfaces, at which the
#    poroelastic parameters are discontinuous, are all defined by two data
#    lines (upper-side and lower-side values). This input format could also be
#    used for a graphic plot of the layered model. Layers which have different
#    parameter values at top and bottom, will be treated as layers with a
#    constant gradient, and will be discretised to a number of homogeneous
#    sublayers. Errors due to the discretisation are limited within about 5%%
#    (changeable, see dgalloc.f).
#
# 2....    parameters of the multilayered model
#
#
#------------------------------------------------------------------------------
 %(n_model_lines)i                               |int: no_model_lines;
#------------------------------------------------------------------------------
# no  depth[km]  vp[km/s]  vs[km/s]  rho[g/cm^3]
#------------------------------------------------------------------------------
%(model_lines)s
#=======================end of input===========================================
'''  # noqa

        return (template % d).encode('ascii')


class DGrnError(gf.store.StoreError):
    pass


class Interrupted(gf.store.StoreError):
    def __str__(self):
        return 'Interrupted.'


class DGrnRunner(object):

    def __init__(self, tmp=None, keep_tmp=False):
        self.tempdir = mkdtemp(prefix='dgrnrun-', dir=tmp)
        self.keep_tmp = keep_tmp
        self.config = None

    def run(self, config):
        self.config = config

        input_fn = pjoin(self.tempdir, 'input')

        with open(input_fn, 'wb') as f:
            input_str = config.string_for_config()
            logger.debug('===== begin dgrn input =====\n'
                         '%s===== end dgrn input =====' % input_str.decode())
            f.write(input_str)

        program = program_bins['dgrn.%s' % config.dgrn_version]

        old_wd = os.getcwd()

        os.chdir(self.tempdir)

        interrupted = []

        def signal_handler(signum, frame):
            os.kill(proc.pid, signal.SIGTERM)
            interrupted.append(True)

        original = signal.signal(signal.SIGINT, signal_handler)
        try:
            try:
                proc = Popen(program, stdin=PIPE, stdout=PIPE, stderr=PIPE)

            except OSError:
                os.chdir(old_wd)
                raise DGrnError(
                    '''could not start dgrn executable: "%s"
Available fomosto backends and download links to the modelling codes are listed
on

      https://pyrocko.org/docs/current/apps/fomosto/backends.html

''' % program)

            (output_str, error_str) = proc.communicate(b'input\n')

        finally:
            signal.signal(signal.SIGINT, original)

        if interrupted:
            raise KeyboardInterrupt()

        logger.debug('===== begin dgrn output =====\n'
                     '%s===== end dgrn output =====' % output_str.decode())

        errmess = []
        if proc.returncode != 0:
            errmess.append(
                'dgrn had a non-zero exit state: %i' % proc.returncode)

        if error_str:
            logger.warn(
                'dgrn emitted something via stderr:\n\n%s'
                % error_str.decode())

            # errmess.append('dgrn emitted something via stderr')

        if output_str.lower().find(b'error') != -1:
            errmess.append("the string 'error' appeared in dgrn output")

        if errmess:
            self.keep_tmp = True

            os.chdir(old_wd)
            raise DGrnError('''
===== begin dgrn input =====
%s===== end dgrn input =====
===== begin dgrn output =====
%s===== end dgrn output =====
===== begin dgrn error =====
%s===== end dgrn error =====
%s
dgrn has been invoked as "%s"
in the directory %s'''.lstrip() % (
                input_str.decode(), output_str.decode(), error_str.decode(),
                '\n'.join(errmess), program, self.tempdir))

        self.dgrn_output = output_str
        self.dgrn_error = error_str

        os.chdir(old_wd)

    def get_results(self):
        # ToDo extract displacements from store
        pass

    def __del__(self):
        if self.tempdir:
            if not self.keep_tmp:
                shutil.rmtree(self.tempdir)
                self.tempdir = None
            else:
                logger.warn(
                    'not removing temporary directory: %s' % self.tempdir)


class DGrnGFBuilder(gf.builder.Builder):
    nsteps = 1

    def __init__(self, store_dir, step, shared, block_size=None, tmp=None,
                 force=False):

        self.store = gf.store.Store(store_dir, 'w')

        storeconf = self.store.config

        if block_size is None:
            block_size = (1, storeconf.nsource_depths, storeconf.ndistances)
            # check block size definition depending on ... N layers, displacements?

        gf.builder.Builder.__init__(
            self, storeconf, step, block_size=block_size, force=force)

        baseconf = self.store.get_extra('dgrn')

        conf = DGrnConfigFull(**baseconf.items())
        conf.earthmodel_1d = self.store.config.earthmodel_1d
        conf.earthmodel_receiver_1d = self.store.config.earthmodel_receiver_1d

        self.dgrn_config = conf

        self.tmp = tmp
        if self.tmp is not None:
            util.ensuredir(self.tmp)

    def work_block(self, index):
        pass
#         (sz, firstx), (sz, lastx), (ns, nx) = \
#             self.get_block_extents(index)

#         logger.info(
#             'Starting block %i / %i' % (index+1, self.nblocks))

#         interrupted = []

#         def signal_handler(signum, frame):
#             interrupted.append(True)

#         original = signal.signal(signal.SIGINT, signal_handler)
#         self.store.lock()
#         duplicate_inserts = 0
#         try:
#             for x in num.linspace(firstx, lastx, nx):
#                 for ig in range(self.store.config.ncomponents):
#                     args = (sz, x, ig)
#                     irec = self.store.config.irecord(*args)
#                     tr = trace.Trace(
#                         deltat=self.store.config.deltat,
#                         ydata=num.zeros(10000)+float(irec))

#                     gf_tr = gf.store.GFTrace.from_trace(tr)

#                     try:
#                         self.store.put(args, gf_tr)
#                     except gf.store.DuplicateInsert:
#                         duplicate_inserts += 1

#         finally:
#             if duplicate_inserts:
#                 logger.warn(
#                     '%i insertions skipped (duplicates)' % duplicate_inserts)

#             self.store.unlock()
#             signal.signal(signal.SIGINT, original)

#         if interrupted:
#             raise KeyboardInterrupt()

#         logger.info('Done with block %i / %i' % (index+1, self.nblocks))


# km = 1000.


def init(store_dir, variant):
    if variant is None:
        variant = '2020'

    if ('dgrn.' + variant) not in program_bins:
        raise gf.store.StoreError('unsupported dgrn variant: %s' % variant)

    modelling_code_id = 'dgrn.%s' % variant

    dgrn = DGrnConfig(version=variant)

    store_id = os.path.basename(os.path.realpath(store_dir))

    config = gf.meta.ConfigTypeA(
        id=store_id,
        ncomponents=10,
        sample_rate=1.0,  # ToDo what does the sample rate means here? Neglect?
        receiver_depth=0*km,
        source_depth_min=0*km,
        source_depth_max=400*km,
        source_depth_delta=4*km,
        distance_min=4*km,
        distance_max=400*km,
        distance_delta=4*km,
        earthmodel_1d=cake.load_model().extract(depth_max=560.*km),
        modelling_code_id=modelling_code_id)

    config.validate()
    return gf.store.Store.create_editables(store_dir, config=config,
                                           extra={'dgrn': dgrn})


def build(
        store_dir,
        force=False,
        nworkers=None,
        continue_=False,
        step=None,
        iblock=None):

    return DGrnGFBuilder.build(
        store_dir, force=force, nworkers=nworkers, continue_=continue_,
        step=step, iblock=iblock)
